/**
 * generated by Xtext
 */
package org.example.expressions.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.example.expressions.expressions.And;
import org.example.expressions.expressions.Comparison;
import org.example.expressions.expressions.Equality;
import org.example.expressions.expressions.Expression;
import org.example.expressions.expressions.ExpressionsPackage;
import org.example.expressions.expressions.ExpressionsPackage.Literals;
import org.example.expressions.expressions.Minus;
import org.example.expressions.expressions.MulOrDiv;
import org.example.expressions.expressions.Not;
import org.example.expressions.expressions.Or;
import org.example.expressions.expressions.Plus;
import org.example.expressions.expressions.Variable;
import org.example.expressions.expressions.VariableRef;
import org.example.expressions.typing.ExpressionsModelUtil;
import org.example.expressions.typing.ExpressionsType;
import org.example.expressions.typing.ExpressionsTypeProvider;
import org.example.expressions.validation.AbstractExpressionsValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class ExpressionsValidator extends AbstractExpressionsValidator {
  public final static String FORWARD_REFERENCE = "org.example.expressions.ForwardReference";
  
  public final static String WRONG_TYPE = "org.example.expressions.WrongType";
  
  @Inject
  @Extension
  private ExpressionsTypeProvider _expressionsTypeProvider;
  
  @Check
  public void checkForwardReference(final VariableRef varRef) {
    final Variable variable = varRef.getVariable();
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(variable, null));
    if (!_notEquals) {
      _and = false;
    } else {
      List<Variable> _variablesDefinedBefore = ExpressionsModelUtil.variablesDefinedBefore(varRef);
      boolean _contains = _variablesDefinedBefore.contains(variable);
      boolean _not = (!_contains);
      _and = (_notEquals && _not);
    }
    if (_and) {
      String _name = variable.getName();
      String _plus = ("variable forward reference not allowed: \'" + _name);
      String _plus_1 = (_plus + "\'");
      EReference _variableRef_Variable = ExpressionsPackage.eINSTANCE.getVariableRef_Variable();
      String _name_1 = variable.getName();
      this.error(_plus_1, _variableRef_Variable, 
        ExpressionsValidator.FORWARD_REFERENCE, _name_1);
    }
  }
  
  @Check
  public void checkType(final Not not) {
    Expression _expression = not.getExpression();
    this.checkExpectedBoolean(_expression, 
      Literals.NOT__EXPRESSION);
  }
  
  @Check
  public void checkType(final MulOrDiv mulOrDiv) {
    Expression _left = mulOrDiv.getLeft();
    this.checkExpectedInt(_left, 
      Literals.MUL_OR_DIV__LEFT);
    Expression _right = mulOrDiv.getRight();
    this.checkExpectedInt(_right, 
      Literals.MUL_OR_DIV__RIGHT);
  }
  
  @Check
  public void checkType(final Minus minus) {
    Expression _left = minus.getLeft();
    this.checkExpectedInt(_left, 
      Literals.MINUS__LEFT);
    Expression _right = minus.getRight();
    this.checkExpectedInt(_right, 
      Literals.MINUS__RIGHT);
  }
  
  @Check
  public void checkType(final And and) {
    Expression _left = and.getLeft();
    this.checkExpectedBoolean(_left, 
      Literals.AND__LEFT);
    Expression _right = and.getRight();
    this.checkExpectedBoolean(_right, 
      Literals.AND__RIGHT);
  }
  
  @Check
  public void checkType(final Or or) {
    Expression _left = or.getLeft();
    this.checkExpectedBoolean(_left, Literals.OR__LEFT);
    Expression _right = or.getRight();
    this.checkExpectedBoolean(_right, 
      Literals.OR__RIGHT);
  }
  
  @Check
  public void checkType(final Equality equality) {
    Expression _left = equality.getLeft();
    final ExpressionsType leftType = this.getTypeAndCheckNotNull(_left, 
      Literals.EQUALITY__LEFT);
    Expression _right = equality.getRight();
    final ExpressionsType rightType = this.getTypeAndCheckNotNull(_right, 
      Literals.EQUALITY__RIGHT);
    this.checkExpectedSame(leftType, rightType);
  }
  
  @Check
  public void checkType(final Comparison comparison) {
    Expression _left = comparison.getLeft();
    final ExpressionsType leftType = this.getTypeAndCheckNotNull(_left, 
      Literals.COMPARISON__LEFT);
    Expression _right = comparison.getRight();
    final ExpressionsType rightType = this.getTypeAndCheckNotNull(_right, 
      Literals.COMPARISON__RIGHT);
    this.checkExpectedSame(leftType, rightType);
    this.checkNotBoolean(leftType, Literals.COMPARISON__LEFT);
    this.checkNotBoolean(rightType, Literals.COMPARISON__RIGHT);
  }
  
  @Check
  public void checkType(final Plus plus) {
    Expression _left = plus.getLeft();
    final ExpressionsType leftType = this.getTypeAndCheckNotNull(_left, 
      Literals.PLUS__LEFT);
    Expression _right = plus.getRight();
    final ExpressionsType rightType = this.getTypeAndCheckNotNull(_right, 
      Literals.PLUS__RIGHT);
    boolean _or = false;
    boolean _or_1 = false;
    boolean _equals = Objects.equal(leftType, ExpressionsTypeProvider.intType);
    if (_equals) {
      _or_1 = true;
    } else {
      boolean _equals_1 = Objects.equal(rightType, ExpressionsTypeProvider.intType);
      _or_1 = (_equals || _equals_1);
    }
    if (_or_1) {
      _or = true;
    } else {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(leftType, ExpressionsTypeProvider.stringType));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _notEquals_1 = (!Objects.equal(rightType, ExpressionsTypeProvider.stringType));
        _and = (_notEquals && _notEquals_1);
      }
      _or = (_or_1 || _and);
    }
    if (_or) {
      this.checkNotBoolean(leftType, Literals.PLUS__LEFT);
      this.checkNotBoolean(rightType, Literals.PLUS__RIGHT);
    }
  }
  
  private void checkExpectedSame(final ExpressionsType left, final ExpressionsType right) {
    boolean _and = false;
    boolean _and_1 = false;
    boolean _notEquals = (!Objects.equal(right, null));
    if (!_notEquals) {
      _and_1 = false;
    } else {
      boolean _notEquals_1 = (!Objects.equal(left, null));
      _and_1 = (_notEquals && _notEquals_1);
    }
    if (!_and_1) {
      _and = false;
    } else {
      boolean _notEquals_2 = (!Objects.equal(right, left));
      _and = (_and_1 && _notEquals_2);
    }
    if (_and) {
      String _plus = ("expected the same type, but was " + left);
      String _plus_1 = (_plus + ", ");
      String _plus_2 = (_plus_1 + right);
      EAttribute _eIDAttribute = Literals.EQUALITY.getEIDAttribute();
      this.error(_plus_2, _eIDAttribute, 
        ExpressionsValidator.WRONG_TYPE);
    }
  }
  
  private void checkNotBoolean(final ExpressionsType type, final EReference reference) {
    boolean _equals = Objects.equal(type, ExpressionsTypeProvider.boolType);
    if (_equals) {
      this.error("cannot be boolean", reference, ExpressionsValidator.WRONG_TYPE);
    }
  }
  
  private void checkExpectedBoolean(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, ExpressionsTypeProvider.boolType, reference);
  }
  
  private void checkExpectedInt(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, ExpressionsTypeProvider.intType, reference);
  }
  
  private void checkExpectedType(final Expression exp, final ExpressionsType expectedType, final EReference reference) {
    final ExpressionsType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      String _plus = ("expected " + expectedType);
      String _plus_1 = (_plus + " type, but was ");
      String _plus_2 = (_plus_1 + actualType);
      this.error(_plus_2, reference, ExpressionsValidator.WRONG_TYPE);
    }
  }
  
  private ExpressionsType getTypeAndCheckNotNull(final Expression exp, final EReference reference) {
    ExpressionsType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._expressionsTypeProvider.typeFor(exp);
    }
    ExpressionsType type = _typeFor;
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("null type", reference, ExpressionsValidator.WRONG_TYPE);
    }
    return type;
  }
}
