/*
 * generated by Xtext
 */
package org.example.smalljava.validation
//import org.eclipse.xtext.validation.Check

import org.eclipse.xtext.validation.Check
import org.example.smalljava.smallJava.SJClass
import org.example.smalljava.smallJava.SJField
import org.example.smalljava.smallJava.SJMember
import org.example.smalljava.smallJava.SJMemberSelection
import org.example.smalljava.smallJava.SJMethod
import org.example.smalljava.smallJava.SJReturn
import org.example.smalljava.smallJava.SJVariableDeclaration
import org.example.smalljava.smallJava.SmallJavaPackage

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.example.smalljava.util.SmallJavaModelUtil.*
import com.google.inject.Inject
import org.example.smalljava.typing.SmallJavaTypeProvider
import org.example.smalljava.typing.SmallJavaTypeConformance
import org.example.smalljava.smallJava.SJExpression

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class SmallJavaValidator extends AbstractSmallJavaValidator {

	@Inject extension SmallJavaTypeProvider
	@Inject extension SmallJavaTypeConformance
	
	public static val INCOMPATIBLE_TYPES = 
		"org.example.smalljava.IncompatibleTypes"  

	public static val HIERARCHY_CYCLE = 
		"org.example.smalljava.HierarchyCycle";
	
	public static val FIELD_SELECTION_ON_METHOD = 
		"org.example.smalljava.FieldSelecionOnMethod"
	
	public static val METHOD_INVOCATION_ON_FIELD =
	 	"org.example.smalljava.MethodInvocationOnField"
	
	public static val UNREACHABLE_CODE = 
		"org.example.smalljava.UnreachableCode"
	
	public static val DUPLICATE_ELEMENT = 
	 	"org.example.smalljava.DuplicateElement"
	 	
	public static val INVALID_ARGS = "org.example.smalljava.InvalidArgs"
	 	
	
	
	@Check def void checkCompatibleTypes(SJExpression exp) {
		val actualType = exp.typeFor
		val expectedType = exp.expectedType
		if (expectedType == null || actualType == null)
			return; // nothing to check
		if (!actualType.isConformant(expectedType)) {
			error("Incompatible types. Expected '" + expectedType?.name + "' but was '" + actualType?.name + "'", null,
				INCOMPATIBLE_TYPES);
		}
	}
	
	@Check
	def checkClassHierarchy(SJClass c) {
		if (c.classHierarchy.contains(c)) {
			error("cycle in hierarchy of class '" + c.name + "'", SmallJavaPackage::eINSTANCE.SJClass_Superclass,
				HIERARCHY_CYCLE, c.superclass.name)
		}
	}
	
	@Check
	def void checkMemberSelection(SJMemberSelection sel) {
		val member = sel.member
		if (member != null) {
			if (member instanceof SJField && sel.methodinvocation)
				error(
					'''Method invocation on a field''',
					SmallJavaPackage::eINSTANCE.
						SJMemberSelection_Methodinvocation,
					METHOD_INVOCATION_ON_FIELD)
			if (member instanceof SJMethod && !sel.methodinvocation)
				error('''Field selection on a method''', 
					SmallJavaPackage::eINSTANCE.SJMemberSelection_Member,
					FIELD_SELECTION_ON_METHOD)
		}
	}
	
	@Check
	def void checkNoStatmentAfterReturn(SJReturn ret) {
		val statements = ret.containingBlock.statements
		if (statements.last != ret) {
			// put the error on the statement after the return 
			error("Unreachable code",
				statements.get(statements.indexOf(ret)+1),
				null, // EStructuralFeature
				UNREACHABLE_CODE
			)
		}
	}
	
	@Check def void checkNoDuplicateClass(SJClass c) {
		if (c.containingProgram.classes.exists[
			it != c && it.name == c.name])
			
			error("Duplicate class '" + c.name + "'",
				SmallJavaPackage::eINSTANCE.SJClass_Name,
				DUPLICATE_ELEMENT)
	}
	
	@Check def void checkNoDuplicateMember(SJMember member) {
		val duplicate = member.containingClass.members.findFirst[
			it != member && it.eClass == member.eClass &&
			it.name == member.name]
		
		if (duplicate != null) 
			error("Duplicate member '" + member.name + "'",
				SmallJavaPackage::eINSTANCE.SJMember_Name,
				DUPLICATE_ELEMENT)
	}
	
	@Check def void checkNoDuplicateVariable(SJVariableDeclaration vardecl) {
		val duplicate = vardecl.containingMethod.body.
		getAllContentsOfType(typeof(SJVariableDeclaration)).
			findFirst[it != vardecl && it.name == vardecl.name]
			
		if (duplicate != null)
			error("Duplicate variable declaration '" + vardecl.name + "'",
				SmallJavaPackage::eINSTANCE.SJSymbol_Name,
				DUPLICATE_ELEMENT)
		
	}
	
		@Check
	def void checkMethodInvocationArguments(SJMemberSelection sel) {
		if (sel.member != null && sel.member instanceof SJMethod) {
			val method = sel.member as SJMethod
			if (method.params.size != sel.args.size) {
				error(
					"Invalid number of arguments. The method " + method.memberAsStringWithType +
					" is not applicable for the arguments + sel.argsTypesAsStrings",
					SmallJavaPackage::eINSTANCE.SJMemberSelection_Member,
					INVALID_ARGS
				)
			}
		}
	}
	 
}
